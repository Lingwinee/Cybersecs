# Block vs Stream Ciphers

## üìã Summary

* **Core Concept:** Block and stream ciphers are the two primary categories of symmetric encryption algorithms. Block ciphers encrypt fixed-size chunks of data at a time, while stream ciphers encrypt data one bit or byte at a time using a continuously generated keystream.

> **Takeaways:** Choosing between a block cipher and a stream cipher depends on the use case. Block ciphers (e.g., AES) are preferred for structured, stored data and provide strong integrity guarantees when paired with the correct mode of operation. Stream ciphers (e.g., ChaCha20) are preferred for real-time, continuous data transmission where low latency is critical. Both rely on a secret key, and neither is universally superior ‚Äî security depends on correct implementation.


## üìñ Definition

* **Block Cipher:** A symmetric encryption algorithm that divides plaintext into fixed-length blocks (commonly 128 bits) and applies a keyed permutation to each block independently or in a chained fashion.
* **Stream Cipher:** A symmetric encryption algorithm that generates a pseudo-random keystream from a secret key (and typically a nonce), then combines it with the plaintext ‚Äî usually via XOR ‚Äî one bit or byte at a time.
* **Mode of Operation:** A scheme that defines how a block cipher is applied repeatedly over data longer than a single block (e.g., ECB, CBC, CTR, GCM).
* **Keystream:** A sequence of pseudo-random bits generated by a stream cipher, which is XORed with plaintext to produce ciphertext.
* **Nonce (Number Used Once):** A value that is unique per encryption operation, used in stream ciphers and certain block cipher modes to prevent keystream reuse.
* **Requirements:**
    * Both cipher types require a shared secret key between the sender and the receiver.
    * Stream ciphers require that a nonce-key pair is **never reused**; reuse breaks confidentiality entirely.
    * Block ciphers must use a secure mode of operation; ECB mode is considered insecure for most practical use.
    * Both must be implemented using a cryptographically secure pseudo-random number generator (CSPRNG) for key and nonce generation.


## üìä Complexity Analysis

| Notation | Name | Growth Rate |
| :--- | :--- | :--- |
| $O(1)$ | Constant | Excellent |
| $O(\log n)$ | Logarithmic | Very Good |
| $O(n)$ | Linear | Good |
| $O(n^2)$ | Quadratic | Poor |

For both cipher types, let $n$ be the size of the input data (in blocks or bytes).

* **Block Cipher ‚Äî Worst-Case ($O$):** $O(n)$ ‚Äî each block requires a fixed number of rounds (e.g., AES-128 uses 10 rounds per 128-bit block), so total work scales linearly with data size.
* **Block Cipher ‚Äî Best-Case ($\Omega$):** $\Omega(n)$ ‚Äî every block must be processed; no block can be skipped.
* **Block Cipher ‚Äî Average-Case ($\Theta$):** $\Theta(n)$ ‚Äî performance is deterministic and uniform across all blocks.
* **Stream Cipher ‚Äî Worst-Case ($O$):** $O(n)$ ‚Äî keystream generation and XOR are both linear in the number of bytes.
* **Stream Cipher ‚Äî Best-Case ($\Omega$):** $\Omega(n)$ ‚Äî every byte must be XORed with a keystream byte.
* **Stream Cipher ‚Äî Average-Case ($\Theta$):** $\Theta(n)$ ‚Äî highly predictable; no branching or variable-round structure.

> **Note:** Stream ciphers often have a smaller constant factor than block ciphers in practice, making them faster on resource-constrained hardware (e.g., embedded systems, IoT devices) even though both are asymptotically $O(n)$.


## ‚ùì Why We Use It

* **Confidentiality:** Both cipher types protect data from unauthorized disclosure by transforming readable plaintext into unintelligible ciphertext without the secret key.
* **Performance trade-offs:** Stream ciphers are computationally lightweight and suitable for real-time or low-latency contexts (e.g., TLS, VoIP). Block ciphers in authenticated modes (e.g., AES-GCM) provide both encryption and integrity verification.
* **Protocol design:** Many modern security protocols (TLS 1.3, SSH, IPsec) support both cipher families to accommodate varying hardware capabilities and security requirements.
* **Data at rest vs. data in transit:** Block ciphers are well-suited for encrypting files or disk sectors. Stream ciphers are preferred for continuous network streams where data length is unknown in advance.
* **Resistance to known attacks:** Proper use of either cipher type ‚Äî with correct modes, nonce management, and key lengths ‚Äî provides resistance to brute force, known-plaintext, and chosen-plaintext attacks.


## ‚öôÔ∏è How It Works

### Block Cipher

1. **Step 1 ‚Äî Key Expansion:** The secret key is expanded into a series of round keys using a key schedule algorithm (e.g., AES key expansion).
2. **Step 2 ‚Äî Padding:** If the plaintext length is not a multiple of the block size, it is padded (e.g., PKCS#7 padding).
3. **Step 3 ‚Äî Block Division:** The padded plaintext is split into fixed-size blocks (128 bits for AES).
4. **Step 4 ‚Äî Round Operations:** Each block passes through a fixed number of rounds. Each round applies substitution (SubBytes), permutation (ShiftRows), mixing (MixColumns), and key addition (AddRoundKey).
5. **Step 5 ‚Äî Mode of Operation:** Depending on the chosen mode, blocks may be processed independently (ECB), chained with XOR (CBC), or converted into a stream-like structure (CTR, GCM).

$$C_i = E_K(P_i) \quad \text{(ECB)} \qquad C_i = E_K(P_i \oplus C_{i-1}) \quad \text{(CBC)}$$

### Stream Cipher

1. **Step 1 ‚Äî Initialization:** The cipher is initialized with a secret key $K$ and a nonce $N$.
2. **Step 2 ‚Äî Keystream Generation:** A pseudo-random keystream $Z = z_1, z_2, z_3, \ldots$ is produced from the internal state.
3. **Step 3 ‚Äî Encryption via XOR:** Each plaintext byte $p_i$ is XORed with the corresponding keystream byte $z_i$:

$$C_i = P_i \oplus Z_i$$

4. **Step 4 ‚Äî Decryption:** The same keystream is regenerated from $K$ and $N$; decryption is identical to encryption via XOR.


## üíª Usage / Example

```python
# Example: AES-GCM (Block Cipher) vs ChaCha20-Poly1305 (Stream Cipher)
# using the 'cryptography' library: pip install cryptography

import os
from cryptography.hazmat.primitives.ciphers.aead import AESGCM, ChaCha20Poly1305

# --- Block Cipher: AES-256-GCM ---
key_aes = AESGCM.generate_key(bit_length=256)  # 256-bit key
nonce_aes = os.urandom(12)                       # 96-bit nonce (recommended for GCM)
aes_gcm = AESGCM(key_aes)

plaintext = b"Sensitive data for block cipher encryption."
aad = b"authenticated_but_not_encrypted_header"

ciphertext_aes = aes_gcm.encrypt(nonce_aes, plaintext, aad)
decrypted_aes = aes_gcm.decrypt(nonce_aes, ciphertext_aes, aad)

print(f"[AES-GCM]     Ciphertext (hex): {ciphertext_aes.hex()}")
print(f"[AES-GCM]     Decrypted:        {decrypted_aes}")


# --- Stream Cipher: ChaCha20-Poly1305 ---
key_cc20 = ChaCha20Poly1305.generate_key()  # 256-bit key
nonce_cc20 = os.urandom(12)                  # 96-bit nonce ‚Äî NEVER reuse with same key
chacha = ChaCha20Poly1305(key_cc20)

ciphertext_cc20 = chacha.encrypt(nonce_cc20, plaintext, aad)
decrypted_cc20 = chacha.decrypt(nonce_cc20, ciphertext_cc20, aad)

print(f"[ChaCha20]    Ciphertext (hex): {ciphertext_cc20.hex()}")
print(f"[ChaCha20]    Decrypted:        {decrypted_cc20}")


# --- Comparison ---
# AES-GCM:         Block cipher | Hardware-accelerated (AES-NI) | Best for servers & storage
# ChaCha20-Poly1305: Stream cipher | Software-efficient | Best for mobile & embedded systems
# Both provide: Authenticated Encryption with Associated Data (AEAD)
# Complexity: O(n) for both, where n = length of plaintext in bytes
```


## üîç Block vs Stream ‚Äî Quick Reference

| Property | Block Cipher (AES-GCM) | Stream Cipher (ChaCha20) |
| :--- | :--- | :--- |
| **Input Unit** | Fixed-size block (128 bits) | 1 bit or 1 byte at a time |
| **Key Reuse** | Safe with unique nonce per message | Nonce reuse is **catastrophic** |
| **Speed (software)** | Moderate | Fast |
| **Speed (hardware)** | Very fast (AES-NI) | Fast |
| **Use Case** | File encryption, databases, TLS | VoIP, IoT, TLS (mobile) |
| **Mode Required** | Yes (ECB, CBC, CTR, GCM) | No (inherent streaming) |
| **Parallelizable** | Depends on mode (CTR/GCM: yes) | Generally no |
| **Authenticated Variant** | AES-GCM | ChaCha20-Poly1305 |


## References

* [NIST FIPS 197 ‚Äî Advanced Encryption Standard](https://doi.org/10.6028/NIST.FIPS.197) ‚Äî Official AES specification.
* [RFC 8439 ‚Äî ChaCha20 and Poly1305 for IETF Protocols](https://datatracker.ietf.org/doc/html/rfc8439) ‚Äî Specification for ChaCha20-Poly1305.
* [cryptography.io Documentation](https://cryptography.io/en/latest/hazmat/primitives/aead/) ‚Äî Python library AEAD primitives reference.
* *Introduction to Modern Cryptography* ‚Äî Jonathan Katz & Yehuda Lindell, Chapters 3‚Äì4 (Block Ciphers and Modes of Operation).
* *Cryptography and Network Security* ‚Äî William Stallings, Chapters 6‚Äì7 (Block Cipher Operation & Stream Ciphers).
* [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html) ‚Äî Practical guidance on cipher selection.